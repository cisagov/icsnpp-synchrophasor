module SYNCHROPHASOR;

# Copyright 2023 Battelle Energy Alliance, LLC

##
## ICSNPP - Synchrophasor
##
## C37.118.2-2011 IEEE Standard for Synchrophasor Data Transfer for Power Systems
##   - https://github.com/cisagov/ICSNPP/files/10747425/ieee-standard-for-synchrophasor-data-transfer-for-power-systems_trimmed.pdf
##   - https://github.com/cisagov/icsnpp-synchrophasor/issues/1
##
## Seth Grover, Idaho National Lab, March 2023
##

import spicy;

# C37.118.2-2011, 6.2 Message framework, Table 2, SYNC field definition ################################################
public type FrameTypeCode = enum {
    DATA_FRAME              = 0,
    HEADER_FRAME            = 1,
    CONFIG_1_FRAME          = 2,
    CONFIG_2_FRAME          = 3,
    COMMAND_FRAME           = 4,
    CONFIG_3_FRAME          = 5,
};

public type SyncField = unit() {
    var frameType: FrameTypeCode = FrameTypeCode::Undef;
    var version: uint8 = 0;

    # first byte must be 0xAA (170)
    : uint8 &requires=($$ == 170);

    # remainder of sync field holds protocol version and the frame type code
    : bitfield(8) {
        version : 0..3;
        frameTypeBits : 4..6;
        _ : 7;
    } {
        self.version = $$.version;
        self.frameType = cast<FrameTypeCode>(cast<uint8>($$.frameTypeBits));
    }
};

# C37.118.2-2011, 6.2.2 Time and message time quality ##################################################################
public type FracSec = unit(header : FrameHeader, frms : Frames) {
    var fracSec  : real = 0.0;

    data : bitfield(32) {
        fracSecRaw : 0..23;
        qualityIndicator : 24..27;
        leapSecPending : 28;
        leapSecOccurred : 29;
        leapSecDirection : 30;
        _ : 31;
    };

    # perform calculation of fractional seconds based on configuration's TIME_BASE (C37.118.2-2011, 6.2.2)
    on %done {
        if ((header.dataStreamId in frms.streamSourceIdConfigFrameMap) &&
            (frms.streamSourceIdConfigFrameMap[header.dataStreamId].initialized == True)) {
            self.fracSec = cast<real>(self.data.fracSecRaw) / cast<real>(frms.streamSourceIdConfigFrameMap[header.dataStreamId].timeBase);
        }
    }
};

# C37.118.2-2011, 6.2.1 Overall message ################################################################################
public type FrameHeader = unit(frms : Frames) {
    var timeStamp : time;
    sync : SyncField;
    frameSize : uint16;
    dataStreamId : uint16;
    : uint32 {
        self.timeStamp = cast<time>($$);
    }
    fracSec : FracSec(self, frms) {
        self.timeStamp = self.timeStamp + cast<interval>(self.fracSec.fracSec);
    }
};

# C37.118.2-2011, 6.6 Command frame, Table 14 ##########################################################################
public type CommandFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    cmd : uint16;
    extframe : uint16[] &eod;
};

# C37.118.2-2011, 6.5 Header frame, Table 13 ###########################################################################
public type HeaderFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    var data : string = "";
    : bytes &eod {
        self.data = $$.decode(hilti::Charset::ASCII);
    }
};

# C37.118.2-2011, 6.4 Word definitions unique to configuration frames 1 and 2, Table 9 #################################
# - and/or -
# C37.118.2-2011, 6.4 Word definitions unique to configuration frame 3, Table 11 #######################################

public type ConfigFormat = unit() {
    format : bitfield(16) {
        phasorShape : 0;  # 0 = phasor real and imaginary (rectangular), 1 = magnitude and angle (polar)
        phasorFormat : 1; # 0 = phasors 16-bit integer, 1 = floating point
        analogFormat : 2; # 0 = analogs 16-bit integer, 1 = floating point
        freqFormat : 3;   # 0 = FREQ/DFREQ 16-bit integer, 1 = floating point
        _ : 4..15;        # unused
    };
} &convert=self.format;

public type PhasorConversionFactor = unit(frameType : FrameTypeCode) {

    # CFG-1 and CFG-2
    format : bitfield(32) {
        phunit : 0..7;
        phvalue : 8..31;
    } if (frameType != FrameTypeCode::CONFIG_3_FRAME);

    # CFG-3
    flags : bitfield(16) {
        _ : 0;
        upsampledInterpolation : 1;
        upsampledExtrapolation : 2;
        downsampledReselection : 3;
        downsampledFIRFilter : 4;
        downsampledNoFIRFilter : 5;
        filteredWithoutChangingSamplint : 6;
        calibrationMagAdj : 7;
        calibrationPhasAdj : 8;
        rotationPhaseAdj : 9;
        pseudoPhasorVal : 10;
        _ : 11..14;
        modAppl : 15;
    } if (frameType == FrameTypeCode::CONFIG_3_FRAME);
    typeInd : bitfield(8) {
        phasorComponent : 0..2;
        phasorType : 3;
        _ : 4..7;
    } if (frameType == FrameTypeCode::CONFIG_3_FRAME);
    userDef : uint8 if (frameType == FrameTypeCode::CONFIG_3_FRAME);
    scaleFactor : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (frameType == FrameTypeCode::CONFIG_3_FRAME);
    angleAdj : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (frameType == FrameTypeCode::CONFIG_3_FRAME);

};

public type AnalogConversionFactor = unit(frameType : FrameTypeCode) {
    # CFG-1 and CFG -2
    var analogFlags : uint8 = 0;
    var userDefinedScaling : int32 = 0;

    : bitfield(32) {
        analogFlags : 0..7;
        userDefinedScaling : 8..31;
    } if (frameType != FrameTypeCode::CONFIG_3_FRAME) {
        self.analogFlags = cast<uint8>($$.analogFlags);
        self.userDefinedScaling = cast<int32>($$.userDefinedScaling);
    }

    # CFG-3
    magScale : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (frameType == FrameTypeCode::CONFIG_3_FRAME);
    offset : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (frameType == FrameTypeCode::CONFIG_3_FRAME);
};

public type DigitalStatusMaskWords = unit() {
    normalStatusMask : uint16;
    validInputsMask : uint16;
};

public type NominalLineFreq = unit() {
    code : bitfield(16) {
        fundamentalFreq : 0;
        _ : 1..15;
    };
} &convert=self.code;

# C37.118.2-2011, 6.4 Configuration-1 and -2 frame, Table 8 ############################################################
# C37.118.2-2011, 6.4 Configuration-3 frame, Table 10 ##################################################################
public type ConfigFrame = unit(header : FrameHeader, inout frms : Frames, chk : uint16) {
    var initialized : bool = False;
    var cfgNum : bool = False;
    var timeBase : uint32 = 1000000;
    var contIdx : uint16 = 0;
    var numPMUActual : uint16 = 0;
    var allStationNames : vector<string>;
    var allPhasorNames : vector<string>;
    var allAnalogNames : vector<string>;
    var allDigitalNames : vector<string>;

    : uint16 if (header.sync.frameType == FrameTypeCode::CONFIG_3_FRAME) {
        self.contIdx = $$;
    }

    : bitfield(32) {
        subdivision : 0..23;
        _ : 24..31;
    } {
        if ($$.subdivision > 0) {
            self.timeBase = $$.subdivision;
        }
    }

    numPMUExpected : uint16;
    pmuCfgs : PMUConfig(header, frms, self)[self.numPMUExpected];
    dataRate : int16;

    : bytes &eod; # any remaining unparsed data

    on %done {
        if ((self?.pmuCfgs) && (|self.pmuCfgs| > 0)) {
            for (pmu in self.pmuCfgs) {
                if (pmu.initialized == True) {
                    if ((pmu?.stationName) && (|pmu.stationName| > 0)) {
                        self.allStationNames.push_back(pmu.stationName);
                    }
                    for (ph in pmu.phnam) {
                        if (|ph| > 0) {
                            self.allPhasorNames.push_back(ph);
                        }
                    }
                    for (an in pmu.annam) {
                        if (|an| > 0) {
                            self.allAnalogNames.push_back(an);
                        }
                    }
                    for (dg in pmu.dgnam) {
                        if (|dg| > 0) {
                            self.allDigitalNames.push_back(dg);
                        }
                    }
                }
            }
        }
        self.initialized = (self.numPMUActual == self.numPMUExpected);
        frms.streamSourceIdConfigFrameMap[header.dataStreamId] = self;
    }
};

# CFG-1 and CFG-2: Table 8  - fields 8-19
# CFG-3:           Table 10 - fields 9-27
public type PMUConfig = unit(header : FrameHeader, inout frms : Frames, inout cfgFrm : ConfigFrame) {
    var frameType: FrameTypeCode = FrameTypeCode::Undef;     # stored from header.sync.frameType
    var initialized : bool = False;                          # set to True on %done
    var pmuIdx : uint16 = 0;                                 # position in parent's (cfgFrm's) pmuCfgs
    var svcClass : string = "";                              # only for CFG-3
    var dgnmrMult : uint32;                                  # used for the byte length of the dgnam field

    stationName : NameField(header.sync.frameType);

    dataSourceId : uint16 {
        self.frameType = header.sync.frameType;
    }

    globalPMUID : bytes &size = 16 if (self.frameType == FrameTypeCode::CONFIG_3_FRAME);

    format : ConfigFormat;

    # phasor/analog/digital counts
    phnmr : uint16;
    annmr : uint16;
    dgnmr : uint16 {
        # used for the byte length of the dgnam field
        if (self.frameType == FrameTypeCode::CONFIG_3_FRAME) {
            self.dgnmrMult = 1;
        } else {
            self.dgnmrMult = 16;
        }
    }

    # phasor/analog/digital names
    phnam : NameField(self.frameType)[self.phnmr];
    annam : NameField(self.frameType)[self.annmr];
    dgnam : NameField(self.frameType)[self.dgnmrMult * self.dgnmr];

    # conversion factor for phasor channels
    phunit : PhasorConversionFactor(self.frameType)[self.phnmr];

    # conversion factor for analog channels
    anunit : AnalogConversionFactor(self.frameType)[self.annmr];

    # mask words for digital status words
    digunit : DigitalStatusMaskWords[self.dgnmr];

    # WGS84 datum for PMU location (CFG-3)
    pmuLat : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (self.frameType == FrameTypeCode::CONFIG_3_FRAME);
    pmuLon : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (self.frameType == FrameTypeCode::CONFIG_3_FRAME);
    pmuElev : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (self.frameType == FrameTypeCode::CONFIG_3_FRAME);

    # service class, measurement window and measurement group delay (CFG-3)
    : bytes &size = 1 if (self.frameType == FrameTypeCode::CONFIG_3_FRAME) {
        self.svcClass = $$.decode(hilti::Charset::ASCII);
    }
    window : int32 if (self.frameType == FrameTypeCode::CONFIG_3_FRAME);
    groupDelay : int32 if (self.frameType == FrameTypeCode::CONFIG_3_FRAME);

    # nominal line frequency code and flags
    fnom : uint16;

    # configuration change count
    cfgcnt : uint16;

    on %done {
        self.pmuIdx = cfgFrm.numPMUActual;
        cfgFrm.numPMUActual += 1;
        self.initialized = True;
    }
};

# 16-bytes interpreted as an ASCII-encoded string (for CFG-1 and CFG-2) #################################################
#  - OR -
# C37.118.2-2011, 6.4 Name field description, table 12 (for CFG-3) ######################################################
type NameField = unit(frameType : FrameTypeCode) {
    var trimmedName : string = "";

    : bytes &size = 16 if (frameType != FrameTypeCode::CONFIG_3_FRAME) {
        self.trimmedName = $$.decode(hilti::Charset::ASCII);
        # TODO: spicy bug here (error ...: bound object has expired)
        # self.trimmedName = $$.strip(spicy::Side::Both).decode(hilti::Charset::ASCII);
        #
        # https://github.com/zeek/spicy/issues/1390
        # repro per @bbanier:
        #      global input = b"   123   ";
        #      public type X = unit {
        #          var s: string;
        #          x: bytes &eod &parse-from=input {
        #              self.s = $$.strip(spicy::Side::Both).decode(spicy::Charset::ASCII);
        #          }
        #      };
    }

    nameLen : uint8 if (frameType == FrameTypeCode::CONFIG_3_FRAME);
    : bytes &size = self.nameLen if (frameType == FrameTypeCode::CONFIG_3_FRAME) {
        self.trimmedName = $$.decode(hilti::Charset::UTF8);
    }

} &convert=self.trimmedName;

# C37.118.2-2011, 6.3 Data frame, Table 5 and Table 6 ##################################################################
public type DataFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    var initialized : bool = False;  # set to True on %done
    var cfgFrame : ConfigFrame;
    var cfgFound : bool = False;
    var numPMUExpected : uint16 = 0;
    var numPMUActual : uint16 = 0;

    data: PMUData(header, frms, self)[] &eod;

    on %done {
        self.initialized = ((self.cfgFound == True) && (self.numPMUExpected == self.numPMUActual));
        print self;
    }
};

public type PMUData = unit(header : FrameHeader, frms : Frames, inout dataFrm : DataFrame) {
    var initialized : bool = False;  # set to True on %done
    var pmuFound : bool = False;
    var pmuIdx : uint16 = 0;         # position in parent's (dataFrm's) data
    var pmuCfg : PMUConfig;

    stat : bitfield(16) {
        triggerReason : 0..3;
        unlockedTime : 4..5;
        pmuTimeQuality : 6..8;
        dataModified : 9;
        configChange : 10;
        pmuTriggerPickup : 11;
        dataSortingType : 12;
        pmuSyncError : 13;
        dataErrorIndicator : 14..15;
    } {
        self.pmuIdx = dataFrm.numPMUActual;
        dataFrm.numPMUActual += 1;

        if ((dataFrm.cfgFound == False) &&
            (header.dataStreamId in frms.streamSourceIdConfigFrameMap) &&
            (frms.streamSourceIdConfigFrameMap[header.dataStreamId].initialized == True)) {
            dataFrm.cfgFrame = frms.streamSourceIdConfigFrameMap[header.dataStreamId];
            dataFrm.numPMUExpected = dataFrm.cfgFrame.numPMUExpected;
            dataFrm.cfgFound = True;
        }
        if ((dataFrm.cfgFound == True) &&
            (self.pmuIdx < |dataFrm.cfgFrame.pmuCfgs|) &&
            (dataFrm.cfgFrame.pmuCfgs[self.pmuIdx].initialized == True)) {
            self.pmuCfg = dataFrm.cfgFrame.pmuCfgs[self.pmuIdx];
            self.pmuFound = True;
        }
    }

    phasors : PhasorEstimate(self.pmuCfg)[self.pmuCfg.phnmr]   if ((self.pmuFound == True) &&
                                                                   (self.pmuCfg.phnmr > 0));
    freq    : FrequencyDeviation(self.pmuCfg)                  if (self.pmuFound == True);
    dfreq   : ROCOF(self.pmuCfg)                               if (self.pmuFound == True);
    analog  : AnalogData(self.pmuCfg)[self.pmuCfg.annmr]       if ((self.pmuFound == True) &&
                                                                   (self.pmuCfg.annmr > 0));
    digital : uint16[self.pmuCfg.dgnmr]                        if ((self.pmuFound == True) &&
                                                                   (self.pmuCfg.dgnmr > 0));
    on %done {
        self.initialized = (self.pmuFound == True);
        print self;
    }
};

# Data type indicated by the FORMAT field in configuration 1, 2, and 3 frames
# 16-bit integer values:
# Rectangular format:
# -real and imaginary, real value first
# -16-bit signed integers, range –32 767 to +32 767
# Polar format:
# -magnitude and angle, magnitude first
# -magnitude 16-bit unsigned integer range 0 to 65535
# -angle 16-bit signed integer, in radians × 10 4 , range –31 416 to +31 416
#
# 32-bit values in IEEE floating-point format:
# Rectangular format:
# -real and imaginary, in engineering units, real value first
# Polar format:
# -magnitude and angle, magnitude first and in engineering units
# -angle in radians, range –π to + π
public type PhasorEstimate = unit(pmuCfg : PMUConfig) {
    rectangular : PhasorRectangular(pmuCfg) if (pmuCfg.format.phasorShape == 0);
    polar       : PhasorRectangular(pmuCfg) if (pmuCfg.format.phasorShape == 1);
};

public type PhasorRectangular = unit(pmuCfg : PMUConfig) {
    realValInt          : int16                                                                        if (pmuCfg.format.phasorFormat == 0);
    realValFloat        : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.phasorFormat == 1);
    imaginaryValInt     : int16                                                                        if (pmuCfg.format.phasorFormat == 0);
    imaginaryValFloat   : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.phasorFormat == 1);
};

public type PhasorPolar = unit(pmuCfg : PMUConfig) {
    magnitudeValInt     : uint16                                                                       if (pmuCfg.format.phasorFormat == 0);
    magnitudeValFloat   : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.phasorFormat == 1);
    angleValInt         : int16                                                                        if (pmuCfg.format.phasorFormat == 0);
    angleValFloat       : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.phasorFormat == 1);
};

# Frequency deviation from nominal, in mHz
# Range–nominal (50 Hz or 60 Hz) –32.767 to +32.767 Hz
# 16-bit integer or 32-bit floating point
# 16-bit integer: 16-bit signed integers, range –32 767 to +32 767
# 32-bit floating point: actual frequency value in IEEE floating-point format.
# Data type indicated by the FORMAT field in configuration 1, 2, and 3 frames
public type FrequencyDeviation = unit(pmuCfg : PMUConfig) {
    freqDevMhzInt   : int16                                                                        if (pmuCfg.format.freqFormat == 0);
    freqDevMhzFloat : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.freqFormat == 1);
};

# ROCOF, in hertz per second times 100
# Range –327.67 to +327.67 Hz per second
# Can be 16-bit integer or IEEE floating point, same as FREQ above. Data type indicated
# by the FORMAT field in configuration 1, 2, and 3 frames
public type ROCOF = unit(pmuCfg : PMUConfig) {
    rocofInt   : int16                                                                        if (pmuCfg.format.freqFormat == 0);
    rocofFloat : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.freqFormat == 1);
};

# Analog word. 16-bit integer. It could be sampled data such as control signal or
# transducer value. Values and ranges defined by user.
# Can be 16-bit integer or IEEE floating point. Data type indicated by the FORMAT field
# in configuration 1, 2, and 3 frames
public type AnalogData = unit(pmuCfg : PMUConfig) {
    analogDataInt   : int16                                                                        if (pmuCfg.format.analogFormat == 0);
    analogDataFloat : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big if (pmuCfg.format.analogFormat == 1);
};

# Fallback unit for incorrectly formatted frames #######################################################################
type NotImplemented = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    : bytes &eod; # any remaining unparsed data
};

# C37.118.2-2011, 6.2.1 Overall message ################################################################################
public type Frame = unit(inout frms : Frames) {
    var parseError : bool = False;

    header : FrameHeader(frms);
    _payload : bytes &size=(self.header.frameSize - 16);
    chk : uint16;

    switch (self.header.sync.frameType) {
        FrameTypeCode::DATA_FRAME     -> DATA_FRAME       : DataFrame(self.header, frms, self.chk);
        FrameTypeCode::HEADER_FRAME   -> HEADER_FRAME     : HeaderFrame(self.header, frms, self.chk);
        FrameTypeCode::COMMAND_FRAME  -> COMMAND_FRAME    : CommandFrame(self.header, frms, self.chk);
        FrameTypeCode::CONFIG_1_FRAME,
        FrameTypeCode::CONFIG_2_FRAME,
        FrameTypeCode::CONFIG_3_FRAME -> CONFIG_FRAME     : ConfigFrame(self.header, frms, self.chk);
        *                             ->                  : NotImplemented(self.header, frms, self.chk);
    } &parse-from=self._payload if (self.header.sync.frameType);

    on %error {
      self.parseError = True;
    }
};

public type Frames = unit() {
    var streamSourceIdConfigFrameMap : map<uint16, ConfigFrame>;
    frms : Frame(self)[];
};
