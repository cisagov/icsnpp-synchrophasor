module SYNCHROPHASOR;

# Copyright 2023 Battelle Energy Alliance, LLC

##
## ICSNPP - Synchrophasor
##
## C37.118.2-2011 IEEE Standard for Synchrophasor Data Transfer for Power Systems
##   - https://github.com/cisagov/ICSNPP/files/10747425/ieee-standard-for-synchrophasor-data-transfer-for-power-systems_trimmed.pdf
##   - https://github.com/cisagov/ICSNPP/issues/4
##
## Seth Grover, Idaho National Lab, March 2023
##

import spicy;

# Frames.configFrameIdx holds the index of the last configuration
const CONFIG_FRAME_IDX_UNSET : uint64 = 0xffffffffffffffff;

# C37.118.2-2011, 6.2 Message framework, Table 2, SYNC field definition ################################################
public type FrameTypeCode = enum {
    DATA_FRAME              = 0,
    HEADER_FRAME            = 1,
    CONFIG_1_FRAME          = 2,
    CONFIG_2_FRAME          = 3,
    COMMAND_FRAME           = 4,
    CONFIG_3_FRAME          = 5,
};

public type SyncField = unit() {
    var frameType: FrameTypeCode = FrameTypeCode::Undef;
    var version: uint8 = 0;

    # first byte must be 0xAA (170)
    : uint8 &requires=($$ == 170);

    # remainder of sync field holds protocol version and the frame type code
    : bitfield(8) {
        version : 0..3;
        frameTypeBits : 4..6;
        _ : 7;
    } {
        self.version = $$.version;
        self.frameType = cast<FrameTypeCode>(cast<uint8>($$.frameTypeBits));
    }
};

# C37.118.2-2011, 6.2.2 Time and message time quality ##################################################################
public type FracSec = unit(header : FrameHeader, frms : Frames) {
    var fracSec  : real = 0.0;

    data : bitfield(32) {
        fracSecRaw : 0..23;
        qualityIndicator : 24..27;
        leapSecPending : 28;
        leapSecOccurred : 29;
        leapSecDirection : 30;
        _ : 31;
    };

    # perform calculation of fractional seconds based on configuration's TIME_BASE (C37.118.2-2011, 6.2.2)
    on %done {
        if (header.dataStreamId in frms.streamSourceIdConfigFrameMap) {
            self.fracSec = cast<real>(self.data.fracSecRaw) / cast<real>(frms.streamSourceIdConfigFrameMap[header.dataStreamId].timeBase);
        }
    }
};

# C37.118.2-2011, 6.2.1 Overall message ################################################################################
public type FrameHeader = unit(frms : Frames) {
    var timeStamp : time;
    sync : SyncField;
    frameSize : uint16;
    dataStreamId : uint16;
    : uint32 {
        self.timeStamp = cast<time>($$);
    }
    fracSec : FracSec(self, frms) {
        self.timeStamp = self.timeStamp + cast<interval>(self.fracSec.fracSec);
    }
};

# C37.118.2-2011, 6.6 Command frame, Table 14 ##########################################################################
public type CommandFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    cmd : uint16;
    extframe : uint16[] &eod;
};

# C37.118.2-2011, 6.5 Header frame, Table 13 ###########################################################################
public type HeaderFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    var data : string = "";
    : bytes &eod {
        self.data = $$.decode(hilti::Charset::ASCII);
    }
};

# C37.118.2-2011, 6.4 Word definitions unique to configuration frames 1 and 2, Table 9 #################################
public type ConfigFormat = unit() {
    format : bitfield(16) {
        phasorShape : 0;
        phasorFormat : 1;
        analogFormat : 2;
        freqFormat : 3;
        _ : 4..15;
    };
} &convert=self.format;

public type PhasorConversionFactor = unit() {
    format : bitfield(32) {
        phunit : 0..7;
        phvalue : 8..31;
    };
} &convert=self.format;

public type AnalogConversionFactor = unit() {
    var analogFlags : uint8 = 0;
    var userDefinedScaling : int32 = 0;
    : bitfield(32) {
        analogFlags : 0..7;
        userDefinedScaling : 8..31;
    } {
        self.analogFlags = cast<uint8>($$.analogFlags);
        self.userDefinedScaling = cast<int32>($$.userDefinedScaling);
    }
};

public type DigitalStatusMaskWords = unit() {
    normalStatusMask : uint16;
    validInputsMask : uint16;
};

public type NominalLineFreq = unit() {
    code : bitfield(16) {
        fundamentalFreq : 0;
        _ : 1..15;
    };
} &convert=self.code;

# C37.118.2-2011, 6.4 Word definitions unique to configuration frame 3, Table 11 #######################################
public type PhasorScale = unit() {
    flags : bitfield(16) {
        _ : 0;
        upsampledInterpolation : 1;
        upsampledExtrapolation : 2;
        downsampledReselection : 3;
        downsampledFIRFilter : 4;
        downsampledNoFIRFilter : 5;
        filteredWithoutChangingSamplint : 6;
        calibrationMagAdj : 7;
        calibrationPhasAdj : 8;
        rotationPhaseAdj : 9;
        pseudoPhasorVal : 10;
        _ : 11..14;
        modAppl : 15;
    };
    typeInd : bitfield(8) {
        phasorComponent : 0..2;
        phasorType : 3;
        _ : 4..7;
    };
    userDef : uint8;
    scaleFactor : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
    angleAdj : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
};

public type AnalogScale = unit() {
    magScale : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
    offset : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
};

# C37.118.2-2011, 6.4 Configuration-1 and -2 frame, Table 8 ############################################################
# C37.118.2-2011, 6.4 Configuration-3 frame, Table 10 ##################################################################
public type ConfigFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    var initialized : bool = False;
    var cfgNum : bool = False;
    var timeBase : uint32 = 1000000;
    var contIdx : uint16 = 0;
    var allPhasorNames : vector<string>;
    var allAnalogNames : vector<string>;
    var allDigitalNames : vector<string>;

    : uint16 if (header.sync.frameType == FrameTypeCode::CONFIG_3_FRAME) {
        self.contIdx = $$;
    }

    : bitfield(32) {
        subdivision : 0..23;
        _ : 24..31;
    } {
        if ($$.subdivision > 0) {
            self.timeBase = $$.subdivision;
        }
    }

    numPMU : uint16;

    switch ( header.sync.frameType ) {
        FrameTypeCode::CONFIG_1_FRAME,
        FrameTypeCode::CONFIG_2_FRAME -> pmuCfgs : PMUConfig(frms)[self.numPMU];
        FrameTypeCode::CONFIG_3_FRAME -> pmuCfg3s : PMUConfig3(frms)[self.numPMU];
    };

    dataRate : int16;

    : bytes &eod; # any remaining unparsed data

    on %done {
        self.initialized = True;
        frms.streamSourceIdConfigFrameMap[header.dataStreamId] = self;
        if (|self.pmuCfgs| > 0) {
            for (i in self.pmuCfgs) {
                for (j in i.phnam) {
                    if (|j| > 0) {
                        self.allPhasorNames.push_back(j);
                    }
                }
                for (k in i.annam) {
                    if (|k| > 0) {
                        self.allAnalogNames.push_back(k);
                    }
                }
                for (l in i.dgnam) {
                    if (|l| > 0) {
                        self.allDigitalNames.push_back(l);
                    }
                }
            }
        }
        if (|self.pmuCfg3s| > 0) {
            for (i in self.pmuCfg3s) {
                for (j in i.phnam) {
                    if (|j| > 0) {
                        self.allPhasorNames.push_back(j);
                    }
                }
                for (k in i.annam) {
                    if (|k| > 0) {
                        self.allAnalogNames.push_back(k);
                    }
                }
                for (l in i.dgnam) {
                    if (|l| > 0) {
                        self.allDigitalNames.push_back(l);
                    }
                }
            }
        }
    }
};

public type PMUConfig = unit(frms : Frames) {
    var initialized : bool = False;
    stationName : SimpleName;
    dataSourceId : uint16;
    format : ConfigFormat;
    phnmr : uint16;
    annmr : uint16;
    dgnmr : uint16;
    phnam : SimpleName[self.phnmr];
    annam : SimpleName[self.annmr];
    dgnam : SimpleName[16 * self.dgnmr];
    phunit : PhasorConversionFactor[self.phnmr];
    anunit : AnalogConversionFactor[self.annmr];
    digunit : DigitalStatusMaskWords[self.dgnmr];
    fnom : uint16;
    cfgcnt : uint16;

    on %done {
        self.initialized = True;
        frms.dataSourceIdPmuConfigMap[self.dataSourceId] = self;
    }
};

public type PMUConfig3 = unit(frms : Frames) {
    var initialized : bool = False;
    var svcClass : string = "";
    stationName : NameField;
    dataSourceId : uint16;
    globalPMUID : bytes &size = 16;
    format : ConfigFormat;
    phnmr : uint16;
    annmr : uint16;
    dgnmr : uint16;
    phnam : NameField[self.phnmr];
    annam : NameField[self.annmr];
    dgnam : NameField[self.dgnmr];
    phscale : PhasorScale[self.phnmr];
    anscale : AnalogScale[self.annmr];
    digunit : DigitalStatusMaskWords[self.dgnmr];
    pmuLat : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
    pmuLon : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
    pmuElev : real &type=spicy::RealType::IEEE754_Single &byte-order=spicy::ByteOrder::Big;
    var trimmedName : string = "";
    : bytes &size = 1 {
        self.svcClass = $$.decode(hilti::Charset::ASCII);
    }
    window : int32;
    groupDelay : int32;
    fnom : uint16;
    cfgcnt : uint16;

    on %done {
        self.initialized = True;
        frms.dataSourceIdPmuConfig3Map[self.dataSourceId] = self;
    }
};

# C37.118.2-2011, 6.3 Data frame, Table 5 ##############################################################################
public type DataFrame = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    var cfgFrame : ConfigFrame;
    var numPMU : uint16 = 0;
    var pmuCfg : PMUConfig;
    var pmuCfg3 : PMUConfig3;
    var phnmr : uint16 = 0;
    var annmr : uint16 = 0;
    var dgnmr : uint16 = 0;

    stat : bitfield(16) {
        triggerReason : 0..3;
        unlockedTime : 4..5;
        pmuTimeQuality : 6..8;
        dataModified : 9;
        configChange : 10;
        pmuTriggerPickup : 11;
        dataSortingType : 12;
        pmuSyncError : 13;
        dataErrorIndicator : 14..15;
    } {
        if ((header.dataStreamId in frms.streamSourceIdConfigFrameMap) &&
            (frms.streamSourceIdConfigFrameMap[header.dataStreamId].initialized == True)) {
            self.cfgFrame = frms.streamSourceIdConfigFrameMap[header.dataStreamId];
            self.numPMU = self.cfgFrame.numPMU;
        }
        if ((header.dataStreamId in frms.dataSourceIdPmuConfigMap) &&
            (frms.dataSourceIdPmuConfigMap[header.dataStreamId].initialized == True)) {
            self.pmuCfg = frms.dataSourceIdPmuConfigMap[header.dataStreamId];
            self.phnmr = self.pmuCfg.phnmr;
            self.annmr = self.pmuCfg.annmr;
            self.dgnmr = self.pmuCfg.dgnmr;
        }
        if ((header.dataStreamId in frms.dataSourceIdPmuConfig3Map) &&
            (frms.dataSourceIdPmuConfig3Map[header.dataStreamId].initialized == True)) {
            self.pmuCfg3 = frms.dataSourceIdPmuConfig3Map[header.dataStreamId];
            self.phnmr = self.pmuCfg3.phnmr;
            self.annmr = self.pmuCfg3.annmr;
            self.dgnmr = self.pmuCfg3.dgnmr;
        }
    }

    data: PMUData(self.cfgFrame, self.pmuCfg, self.pmuCfg3)[self.numPMU];
    : bytes &eod; # any remaining unparsed data
};

public type PMUData = unit(cfgFrame : ConfigFrame, pmuCfg : PMUConfig, pmuCfg3 : PMUConfig3) {
  # TODO
};

# Fallback unit for incorrectly formatted frames #######################################################################
type NotImplemented = unit(header : FrameHeader, frms : Frames, chk : uint16) {
    : bytes &eod; # any remaining unparsed data
};

# 16-bytes interpreted as an ASCII-encoded string #######################################################################
type SimpleName = unit() {
    var trimmedName : string = "";
    : bytes &size = 16 {
        self.trimmedName = $$.decode(hilti::Charset::ASCII);
    }
} &convert=self.trimmedName;

# C37.118.2-2011, 6.4 Name field description, table 12 ##################################################################
type NameField = unit() {
    var trimmedName : string = "";
    nameLen : uint8;
    : bytes &size = self.nameLen {
        self.trimmedName = $$.strip(spicy::Side::Both).decode(hilti::Charset::UTF8);
    }
} &convert=self.trimmedName;

# C37.118.2-2011, 6.2.1 Overall message ################################################################################
public type Frame = unit(inout frms : Frames) {
    var parseError : bool = False;

    header : FrameHeader(frms);
    _payload : bytes &size=(self.header.frameSize - 16);
    chk : uint16;

    switch (self.header.sync.frameType) {
        FrameTypeCode::DATA_FRAME     -> DATA_FRAME       : DataFrame(self.header, frms, self.chk);
        FrameTypeCode::HEADER_FRAME   -> HEADER_FRAME     : HeaderFrame(self.header, frms, self.chk);
        FrameTypeCode::COMMAND_FRAME  -> COMMAND_FRAME    : CommandFrame(self.header, frms, self.chk);
        FrameTypeCode::CONFIG_1_FRAME,
        FrameTypeCode::CONFIG_2_FRAME,
        FrameTypeCode::CONFIG_3_FRAME -> CONFIG_FRAME     : ConfigFrame(self.header, frms, self.chk);
        *                             ->                  : NotImplemented(self.header, frms, self.chk);
    } &parse-from=self._payload if (self.header.sync.frameType);

    on %error {
      self.parseError = True;
    }
};

public type Frames = unit() {
    var dataSourceIdPmuConfigMap : map<uint16, PMUConfig>;
    var dataSourceIdPmuConfig3Map : map<uint16, PMUConfig3>;
    var streamSourceIdConfigFrameMap : map<uint16, ConfigFrame>;
    frms : Frame(self)[];
};
